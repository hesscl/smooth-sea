---
title: "smooth-sea"
output: 
  flexdashboard::flex_dashboard:
    navbar:
      - { title: "hesscl.com", href: "http://hesscl.com", align: right }
    orientation: columns
    theme: bootstrap
    logo: logo.svg
    source_code: "https://github.com/hesscl/smooth-sea"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

#packages
library(tidyverse) #need dev version of ggplot
library(forcats)
library(haven)
library(lubridate)
library(haven)
library(zoo)
library(ggthemes)
library(RColorBrewer)
library(sp)
library(spdplyr)
library(geosphere)
library(rgdal)
library(rgeos)
library(sqldf)
library(spdep)
library(viridis)
library(latex2exp)
library(plotly)
library(DT)
library(crosstalk)

#load ACS data extract (codebook in folder)
census <- read_csv(file = "./input/acsExtract.csv")

#read in tract shapefiles for seattle
sea_shp <- readOGR(dsn = "R:/Project/seattle_rental_market/data/geo/sea_tract_2010/sea_tract_2010.shp",
                  layer = "sea_tract_2010",
                  GDAL1_integer64_policy = TRUE,
                  stringsAsFactors = F) 

#determine config (dev or github)
if(file.exists("../data/cl/craigslistDB.sqlite")){
  #connect to database if file.exists
  DB <- dbConnect(SQLite(), dbname="../data/cl/craigslistDB.sqlite")
  cl <- tbl(DB, "clean") #create dbi for clean listing table
  
  #compute tract aggregates for CL listing count
  tract <- cl %>%
    collect %>% #bring db query into memory
    filter(!is.na(GISJOIN), !is.na(cleanBeds), !is.na(cleanRent), !is.na(cleanSqft), 
           GISJOIN %in% sea_shp@data$GISJOIN) %>% #only listings with valid Bed/Rent, seattle tracts
    distinct(cleanBeds, cleanRent, cleanSqft, matchAddress, 
             matchAddress2, .keep_all = T) %>% #dedupe to unique address-bed-rent combos
    dplyr::select(listingDate, GISJOIN, seattle, matchAddress, matchType, 
                  cleanBeds, cleanRent, cleanSqft) %>% #SELECT these columns
    mutate(listingDate = as.Date(listingDate),
           listingQtr = as.yearqtr(listingDate)) %>%
    filter(cleanBeds %in% c(0, 1, 2, 3), listingQtr >= "2017 Q2") %>%
    group_by(GISJOIN, listingQtr) %>% #group listings by tract, qtr within tract
    summarize(nListings = n(),
              n1B = sum(cleanBeds == 1),
              medRent = median(cleanRent),
              med0B = median(cleanRent[cleanBeds==0]),
              med1B = median(cleanRent[cleanBeds==1]),
              med2B = median(cleanRent[cleanBeds==2]),
              med3B = median(cleanRent[cleanBeds==3]),
              lagRent = lag(cleanRent)) %>% #create tract aggregates
    ungroup %>%
    arrange(GISJOIN, listingQtr)
  dbDisconnect(DB)
  write_csv(tract, "./input/tractCl.csv")
  
} else{
  #if github config, read in extract from cl db
  tract <- read_csv("./input/tractCl.csv")
}

full_panel <- tract %>%
  group_by(GISJOIN) %>% 
  summarize(n = n()) %>%
  pull(n) %>%
  max

#### A. construct panel (some missingness) ------------------------------------

#ensure order of census df matches shapefile
census <- census[match(sea_shp@data$GISJOIN, census$GISJOIN),]

#clean a few fields we might use
census <- census %>%
  mutate(nHU = AF7PE001,
         idtract = row_number(),
         pOwnoccHU = AF7PE002/AF7PE001,
         medHUVal = AF9LE001)

#periods <- tract %>%
#  filter(listingQtr != as.yearqtr(Sys.Date())) %>%
#  summarize(n = length(unique(listingQtr))) %>% 
#  pull(n)
           
#store NULL object to bind iterated dfs into
panel <- NULL

#for each unique quarter in the CL data
for(i in unique(as.character(tract$listingQtr))){
  
  period <- tract %>% #start pipe with tract, end with period
    mutate(listingQtr = factor(listingQtr, ordered = T)) %>% #make factor
    filter(listingQtr == i) %>% #filter to qtr i
    right_join(census) %>% #right join to census, allows missingness
    ungroup() %>% #remove grouping by tract
    mutate(listingQtr = i, #listingQtr == current iteration
           Qtr = gsub(pattern = "^\\d{4} ", replacement = "", x = listingQtr)) #subset str to Q1,2,3,4
  panel <- bind_rows(panel, period) #append to panel object
}

sea_df <- panel %>% #set to NA for INLA to forecast
  mutate(actualRent = med1B,
         med1B = ifelse(listingQtr == as.yearqtr(Sys.Date()), NA, med1B)) %>%
  dplyr::select(GISJOIN, listingQtr, Qtr, medRent, med1B, lagRent, actualRent, nHU,
                n1B, nListings, pOwnoccHU, medHUVal, idtract) %>%
  mutate(p1B = n1B/nListings) %>%
  arrange(listingQtr, GISJOIN)

#### B. INLA Models of CL Rent ------------------------------------------------

library(INLA)

#create adjacency matrix from shapefile
sea_adj <- poly2nb(sea_shp)

#create neighbor file that INLA takes for hyperparameter args
nb2INLA("R:/Project/seattle_rental_market/report/spatial_epi/seatract.graph", sea_adj)
sea_df$idqtr <- factor(sea_df$listingQtr, ordered = T)
sea_df$idqtr1 <- sea_df$idqtr
sea_df$idtractqtr <- paste(sea_df$idtract, sea_df$idqtr)
sea_df$idtract1 <- sea_df$idtract

#fixed effect for qtr only
form.int <- log(med1B) ~ 1 + Qtr 

m.int <- inla(form.int, 
             family = "normal", 
             data = sea_df,
             control.predictor = list(compute = TRUE),
             control.compute = list(dic = TRUE, waic = TRUE))

summary(m.int)
sea_df$int_Med <- m.int$summary.linear.predictor[, "0.5quant"]
sea_df$int_SD <- m.int$summary.linear.predictor[, "sd"]
sea_df$int_postWidth <- m.int$summary.linear.predictor[, "0.975quant"] - m.int$summary.linear.predictor[,"0.025quant"]
sea_df$int_Eff <- m.int$summary.random$idtract[sea_df$idtract, "0.5quant"] 

#fixed qtr + iid tract random effect
form.ns <- log(med1B) ~ 1 + Qtr +
   f(idtract, model = "iid")

m.ns <- inla(form.ns, 
              family = "normal", 
              data = sea_df,
              control.predictor = list(compute = TRUE),
              control.compute = list(dic = TRUE, waic = TRUE))

summary(m.ns)
sea_df$ns_Med <- m.ns$summary.linear.predictor[, "0.5quant"]
sea_df$ns_SD <- m.ns$summary.linear.predictor[, "sd"]
sea_df$ns_postWidth <- m.ns$summary.linear.predictor[, "0.975quant"] - m.ns$summary.linear.predictor[,"0.025quant"]
sea_df$ns_Eff <- m.ns$summary.random$idtract[sea_df$idtract, "0.5quant"] 

#IID tract random effect + AR(1) process
form.nsar1 <- log(med1B) ~ 1 +
  f(idtract, model = "iid") +
  f(idqtr, model = "ar1") + f(idqtr1, model = "iid")

m.nsar1 <- inla(form.nsar1, 
               family = "normal", 
               data = sea_df,
               control.predictor = list(compute = TRUE),
               control.compute = list(dic = TRUE, waic = TRUE))

summary(m.nsar1) #NB: does not improve fit to use random effect time specification, using fixed effects
sea_df$nsar1_Med <- m.nsar1$summary.linear.predictor[, "0.5quant"]
sea_df$nsar1_SD <- m.nsar1$summary.linear.predictor[, "sd"]
sea_df$nsar1_postWidth <- m.nsar1$summary.linear.predictor[, "0.975quant"] - m.nsar1$summary.linear.predictor[,"0.025quant"]
sea_df$nsar1_Eff <- m.nsar1$summary.random$idtract[sea_df$idtract, "0.5quant"] 

#spatial random effect model (BYM 1991) with seasonal dummies
form.bym <- log(med1B) ~ 1 + Qtr +
  f(idtract, model = "bym", #ICAR spatial RE for tract neighbors + IID RE for tract
    scale.model = T,
    graph = "R:/Project/seattle_rental_market/report/spatial_epi/seatract.graph")

m.bym <- inla(form.bym, 
             family = "normal", 
             data = sea_df,
             control.predictor = list(compute = TRUE),
             control.compute = list(dic = TRUE, waic = TRUE))

summary(m.bym)
sea_df$bym_Med <- m.bym$summary.linear.predictor[, "0.5quant"]
sea_df$bym_SD <- m.bym$summary.linear.predictor[, "sd"]
sea_df$bym_postWidth <- m.bym$summary.linear.predictor[, "0.975quant"] - m.bym$summary.linear.predictor[,"0.025quant"]
sea_df$bym_Eff <- m.bym$summary.random$idtract[sea_df$idtract, "0.5quant"] 

#spatio-temporal smoothing model with linear space-time interaction (Bernadelli 1995)
form.spt <- log(med1B) ~ 1 + Qtr +
  f(idtract, model = "bym", #ICAR spatial RE for tract neighbors + IID RE for tract
    scale.model = T,
    graph = "R:/Project/seattle_rental_market/report/spatial_epi/seatract.graph") +
  f(idtractqtr, model="iid") + #exchangeable RE for period
  f(idqtr, model = "rw1") 

m.spt <- inla(form.spt, 
              family = "normal", 
              data = sea_df,
              control.predictor = list(compute = TRUE),
              control.compute = list(dic = TRUE, waic = TRUE))

summary(m.spt)
sea_df$spt_Med <- m.spt$summary.linear.predictor[, "0.5quant"]
sea_df$spt_SD <- m.spt$summary.linear.predictor[, "sd"]
sea_df$spt_postWidth <- m.spt$summary.linear.predictor[, "0.975quant"] - m.spt$summary.linear.predictor[,"0.025quant"]
sea_df$spt_Eff <- m.spt$summary.random$idtract[sea_df$idtract, "0.5quant"] 

#overfitting? too much bumpiness qtr-to-qtr

#### Maps of Model Output ------------------------------------------------------------------

sea_df <- sea_df %>%
  mutate_at(.vars = vars(matches("_Med")),
            .funs = exp) %>%
  mutate_at(.vars = vars(matches("_SD")),
            .funs = exp) %>%
  group_by(GISJOIN) %>% 
  arrange(GISJOIN, listingQtr) %>%
  mutate(spt_traj = spt_Med - lag(spt_Med, 4)) %>%
  ungroup %>%
  group_by(GISJOIN) %>%
  mutate(spt_traj = sum(spt_traj, na.rm=T)) %>%
  ungroup() %>%
  mutate(bym_cuts = cut(bym_Med, 6),
         spt_cuts = cut(spt_Med, 6))

sea_df

sea_shp@data$id <- rownames(sea_shp@data)
sea_shp@data <- left_join(sea_shp@data, sea_df)
sea_f <- fortify(sea_shp)
sea_f <- inner_join(sea_f, sea_shp@data,"id")

rmse <- function(error){sqrt(mean(error^2))}
mae <- function(error){mean(abs(error))}

#table of fit statistics
fit_stats <- sea_df %>%
  mutate(train_test = ifelse(listingQtr == as.yearqtr(Sys.Date()), "Test", "Training")) %>%
  mutate(int_err = actualRent - int_Med,
         ns_err = actualRent - ns_Med,
         nsar1_err = actualRent - nsar1_Med,
         bym_err = actualRent - bym_Med,
         spt_err = actualRent - spt_Med) %>% 
  group_by(train_test) %>%
  summarize(int_rmse = rmse(int_err[!is.na(int_err)]),
            int_mae = mae(int_err[!is.na(int_err)]),
            ns_rmse = rmse(ns_err[!is.na(ns_err)]),
            ns_mae = mae(ns_err[!is.na(ns_err)]),
            nsar1_rmse = rmse(nsar1_err[!is.na(nsar1_err)]),
            nsar1_mae = mae(nsar1_err[!is.na(nsar1_err)]),
            bym_rmse = rmse(bym_err[!is.na(bym_err)]),
            bym_mae = mae(bym_err[!is.na(bym_err)]),
            spt_rmse = rmse(spt_err[!is.na(spt_err)]),
            spt_mae = mae(spt_err[!is.na(spt_err)])) %>%
  dplyr::select(train_test, ends_with("_rmse"), ends_with("_mae"))
```


Home {data-icon="fa-home"}
=====================================

Column
-------------------------------------

### Welcome!

This website provides information for the paper _Estimating Neighborhood Asking Rents using Scraped Craigslist Rental Listings_

You can download the R source code and data for this project from Github [here](https://github.com/hesscl/smooth-sea)

Contact Chris Hess at [hesscl@uw.edu](mailto://hesscl@uw.edu) for more information about this report.

_This page was last updated: `r Sys.Date()`_

Column
-------------------------------------

### Observed vs. Smoothed Rent Estimates

```{r index.maps, echo=F}
obs <- sea_f %>%
  mutate(rent = actualRent) %>%
  filter(listingQtr == as.yearqtr(Sys.Date())) %>%
  mutate(var = paste(as.yearqtr(Sys.Date()), "to-Date"))

pred <- sea_f %>%
  mutate(rent = nsar1_Med) %>%
  filter(listingQtr == as.yearqtr(Sys.Date())) %>%
  mutate(var = paste(as.yearqtr(Sys.Date()), "Forecast"))

comb <- bind_rows(obs, pred) %>%
  mutate(tooltip = paste0(NAMELSAD10, "<br>", "Forecast: $", round(nsar1_Med), "<br>", "Qtr-to-Date: $", round(actualRent), "<br>", "N Qtr-to-Date: ", n1B))
comb <- SharedData$new(comb, ~GISJOIN)

avp_map <- ggplot(comb, aes(x = long, y = lat, group = group, fill = rent, label = tooltip)) +
  facet_wrap(~ var) +
  geom_polygon(color = "grey85", lwd = .05) +
  scale_fill_viridis_c(limits = c(750, 2500), labels = scales::dollar) +
  coord_quickmap() +
  theme(axis.title = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        panel.background = element_blank()) +
  labs(fill = "Median<br>1B Rent")

ggplotly(avp_map, tooltip = c("label")) %>%
  layout(autosize = T) %>%
  highlight(on = "plotly_hover", off = NULL)
```

Distribution
=====================================

```{r, echo=F}
gg_hist <- ggplot(sea_df, aes(x = med1B, group = listingQtr, color = listingQtr)) +
  geom_density() +
  theme_minimal() +
  scale_color_viridis_d(end = .8)

ggplotly(gg_hist) %>%
  layout(autosize = T)
```


Panel Time-Series
=====================================

```{r temp.lineplot, echo=F}
obs_df <- sea_df %>%
  group_by(listingQtr) %>%
  mutate(value = actualRent,
         qtrDev = value-mean(value, na.rm=T),
         model = "A. Observed")

int_df <- sea_df %>%
  group_by(listingQtr) %>%
  mutate(value = int_Med,
         qtrDev = value-mean(value, na.rm=T),
         model = "B. Quarter FE")

ns_df <- sea_df %>%
  group_by(listingQtr) %>%
  mutate(value = ns_Med,
         qtrDev = value-mean(value, na.rm=T),
         model = "C. Non-Spatial RE")

nsar1_df <- sea_df %>%
  group_by(listingQtr) %>%
  mutate(value = nsar1_Med,
         qtrDev = value-mean(value, na.rm=T),
         model = "D. Non-Spatial AR(1) RE")

bym_df <- sea_df %>%
  group_by(listingQtr) %>%
  mutate(value = bym_Med,
         qtrDev = value-mean(value, na.rm=T),
         model = "E. Spatial RE")

spt_df <- sea_df %>%
  group_by(listingQtr) %>%
  mutate(value =  spt_Med,
         qtrDev = value-mean(value, na.rm=T),
         model = "F. Spatiotemporal")

panel_df <- bind_rows(obs_df, int_df, ns_df, nsar1_df, bym_df, spt_df)

panel_df <- SharedData$new(panel_df, ~GISJOIN)

obs_lineplot <- ggplot(panel_df, aes(x = listingQtr, y = value, group = GISJOIN, label = GISJOIN, color = qtrDev, frame = model)) +
  geom_line(lwd = .25, color = "black", alpha = .5) +
  geom_point() +
  scale_color_gradient2_tableau()

ggplotly(obs_lineplot, tooltip = c("label", "y")) %>%
  layout(autosize = T) %>%
  animation_opts(frame = 1000, transition = 0, redraw = FALSE) %>%
  animation_button(hide = T) %>%
  highlight(on = "plotly_hover", off = NULL)
```

Spatial Time-Series
=====================================

```{r spat.series, echo=F}
map_panel <- SharedData$new(sea_f, ~GISJOIN)

map_panel_gg <- ggplot(map_panel, aes(x = long, y = lat, group = group, fill = actualRent, label = GISJOIN, frame = listingQtr)) +
  geom_polygon(data=sea_f, aes(fill = NULL, label = NULL), fill = "grey80") +
  geom_polygon(color = "grey85", lwd = .05) +
  scale_fill_viridis_c(labels = scales::dollar, na.value = "grey80") +
  coord_quickmap() +
  theme(axis.title = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        panel.background = element_blank()) +
  labs(fill = "Median<br>1B Rent")
  
ggplotly(map_panel_gg, tooltip = c("label", "fill")) %>%
  layout(autosize = T) %>%
  animation_opts(frame = 1000, transition = 0, redraw = FALSE)
```


Model Fit
=====================================

Column {data-width=400}
-------------------------------------

### RMSE

```{r, echo=F}
knitr::kable(fit_stats %>% select(train_test, ends_with("rmse")))
```

### MAE

```{r, echo=F}
knitr::kable(fit_stats %>% select(train_test, ends_with("mae")))
```

Column {data-width=600}
-------------------------------------

### Actual vs. Predicted Scatterplot

```{r, echo=F}
avp_scatter <- ggplot(sea_df, aes(x = actualRent, y = bym_Med, size = n1B, frame = listingQtr)) +
  geom_point() +
  geom_abline(intercept = 0, slope = 1) +
  scale_size_area() +
  coord_equal() +
  theme_minimal()

ggplotly(avp_scatter) %>%
  layout(autosize = T)
```

Forecast
=====================================


